# 0001.两数之和

两数之和是需要使用哈希法来解决，当碰到需要思考“是否存在过”的问题时可以使用。

哈希表有三种实现，数组，set（集合）和map。

1. 数组的键是下标，是一种天然的哈希表，通过下标值来获取value本身就是哈希表的定义；
2. set主要用来查找集合中是否有某元素，且元素是不重复的；
3. map可以存储key和value，属于键值都是自定义的实现。



# 0005.最长回文串

动态规划五部曲：

1. 确定dp数组及其下标含义

   - 检查一个字符串第一个和最后一个字符是否相同，不断向内如此检查，可以确定一个字符串是否为回文串。
   - 从这个规律中可以发现第一个字符和最后一个字符为关键，所以dp数组可以设为二维数组，下标含义为第一个字符位置和最后一个字符的位置
   - dp[i] [j]为一个布尔值，表示从i到j的子字符串是否为回文串

2. 确定递推公式

   - 对于dp[i] [j]而言，s[i] != s[j] ，那dp[i] [j]所表示的字符串不是回文串
   - 如果s[i] == s[j]，则比较s[i+1] 与 j[j-1]是否相同，即看dp[i] [j]去掉首尾的子字符串是否为回文串，以此递归来判断dp[i] [j]  

3. dp数组如何初始化

   dp数组不能初始化全部赋值为true，否则就没有意义了，应该对所有的初始值都赋值为false

4. 确定遍历顺序/方向

   因为dp[i] [j]的值在s[i] == s[j] 的情况下是需要其子字符串 dp[i+1] [j-1]来确定的，所以对dp的遍历顺序，应该是从下至上，从左往右的。因为j>i,所以遍历的会是斜对角线的上半部分。

5. 举例推导dp数组

上述五部曲中，步骤2 递推公式也可以改为从i和j的距离入手，距离为0则dp[i] [j]为true，距离 > 0 时，判断s[i] == s[j]，后续步骤同上。因为递推公式不同了，所以递推方向也不同，方向即是i、j距离变大的方法。