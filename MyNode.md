# 0001.两数之和

两数之和是需要使用哈希法来解决，当碰到需要思考“是否存在过”的问题时可以使用。

哈希表有三种实现，数组，set（集合）和map。

1. 数组的键是下标，是一种天然的哈希表，通过下标值来获取value本身就是哈希表的定义；
2. set主要用来查找集合中是否有某元素，且元素是不重复的；
3. map可以存储key和value，属于键值都是自定义的实现。



# 0005.最长回文串

动态规划五部曲：

1. 确定dp数组及其下标含义

   - 检查一个字符串第一个和最后一个字符是否相同，不断向内如此检查，可以确定一个字符串是否为回文串。
   - 从这个规律中可以发现第一个字符和最后一个字符为关键，所以dp数组可以设为二维数组，下标含义为第一个字符位置和最后一个字符的位置
   - dp[i] [j]为一个布尔值，表示从i到j的子字符串是否为回文串

2. 确定递推公式

   - 对于dp[i] [j]而言，s[i] != s[j] ，那dp[i] [j]所表示的字符串不是回文串
   - 如果s[i] == s[j]，则比较s[i+1] 与 j[j-1]是否相同，即看dp[i] [j]去掉首尾的子字符串是否为回文串，以此递归来判断dp[i] [j]  

3. dp数组如何初始化

   dp数组不能初始化全部赋值为true，否则就没有意义了，应该对所有的初始值都赋值为false

4. 确定遍历顺序/方向

   因为dp[i] [j]的值在s[i] == s[j] 的情况下是需要其子字符串 dp[i+1] [j-1]来确定的，所以对dp的遍历顺序，应该是从下至上，从左往右的。因为j>i,所以遍历的会是斜对角线的上半部分。

5. 举例推导dp数组

上述五部曲中，步骤2 递推公式也可以改为从i和j的距离入手，距离为0则dp[i] [j]为true，距离 > 0 时，判断s[i] == s[j]，后续步骤同上。因为递推公式不同了，所以递推方向也不同，方向即是i、j距离变大的方法。

# 0015.三数之和

三数之和不能用哈希法处理，去重会比较复杂。因为不求下标，可以用双指针法处理，下面是一些思路（数组为nums）：

1. 先对数组进行从小到大的排序，然后遍历数组，取出位于 i 位置的元素作为第一个数。
2. 对第一个元素进行去重处理：如果和当前元素值和前一个元素值相等则直接跳过处理
3. 取 i+1 位置为左指针位置left，nums.length-1 的位置为右指针位置right
4. 比较 nums[i] + nums[left] + nums[right] 和 0 的大小，大于则 right--，小于则left++
5. 如果等于，则返回这次三个元素，然后对第二个元素和第三个元素进行去重处理
6. 第二个元素去重：循环比较left 和 left++ 位置元素值，等于则left++
7. 第三个元素去重：循环比较right和right-- 位置元素值，等于则right--

三数之和关键是去重。